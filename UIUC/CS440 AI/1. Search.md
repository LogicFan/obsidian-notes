# Search Problem
Artificial Intelligence = Search
States + Actions + Transitions + Goals -> Search Algorithm -> Path or Policy

Example:
- Chess: discrete, deterministic, fully observable, adversarial
- Driving: continuous, stochastic, partially observable, dynamic

Typically we don't want *any* solution, we want the *best* solution. We can have auxiliary objects to minimize or maximize. 
# State Space
A state space is a set $\mathcal{X}$, with unknown global structure $d_\mathcal{X}(x, y)$, and known local structure $N_\mathcal{X}(x) \subset \mathcal{X}$  that $d_\mathcal{X}(x, x'), x' \in N_\mathcal{X}(x)$.

The length of the shortest path from $x$ to $y$ is $d_\mathcal{X}(x, y)$.
# Search Space
A search space is $(\mathcal{X}, N_{\mathcal{X}}, s, R)$ where $s \in \mathcal{X}$ is the starting state and $R: \mathcal{X} \to \{0, 1\}$ is a task.
# Grid
- State space: coordinate in a 2d array of 0s and 1s. 0 is free and 1 is obstacle. 
- Action space: 4 directions. 
# Graph
- State space: Vertices
- Action space: Edges
Graph are everywhere. Grids are also graphs. But by representing a problem into a graph, sometimes you through away useful information.

# Random Walk
```
loop:
	path.append(s)
	if s.is_goal():
		return path
	else:
		s = random.choice(s.get_neighbors())
```

## Does it always find a path? (Completeness): 
No. The state space can be infinitely large, and there may be irreversible actions. 
## Does it find the shortest path? (Optimality): 
No. It does not build a search tree of possibilities but a single walk.
## How quickly does it find a solution (Efficiency)
No. The same state can be visited multiple times and same action can be taken multiple times at that state. 
## Pros
- simple
- no memory
- likely to find a path if one exists. 

# Uninformed Search
## Random Walk with Memory (Not Working)
Adding memory, distinguish between *unexplored* and *explored* states.
```
loop:
	path.append(s)
	visited.add(s)
	if s.is_goal():
		return path
	else:
		loop:
			s_temp = random.choice(s.get(neighbors()))
			if s_temp NOT in visited:
				s = s_temp
				break
```
It will have infinite loop, this is still a walk not a search. 
One solution could be restarting. 
