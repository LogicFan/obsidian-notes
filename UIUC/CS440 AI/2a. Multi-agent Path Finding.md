Curse of dimensionality: problem difficulty depends exponentially on the dimensionality of the problem $O(2^d)$.

The **dimension** of a search problem is the number of features required to describe a state in the state space.
- Grid: $i, j$ coordinates, 2 dimensional, $W^2$ states
- Multi-goal: $d$ goals, number of possible subsets of goals visited is $2^d$.
- Multi-agent: $d$ agents in $S$, number of possible configurations are $|S|^d$. 

Heuristics can help but they don't solve the problem.
Inadmissible heuristics can help a lot more but are very suboptimal.
# Objectives
- Makespan: the time the *last* agent reaches its destination
- Flowtime: sum of times/actions
# Coupled MAPF
The coupled MAPF search space is $(S_i, A_i, s_i, t_i)^K_{i=1}$.
$$\left( S_1 \times S_2 \times \cdots, A_1 \times A_2 \times \cdots, (s_1, s_2, \cdots), (t_1, t_2, \cdots) \right)$$
Notice that the time required to solve $k$ individual search problems is linear, but coupling them this way it becomes exponential. 

For this to be meaningful, we need to assume some kind of dependence between them.
## Shared-space Coupled MAPF
$$(S^K, A^K), (s_i, t_i)^K_{i = 1}, x_i^t \neq x_j^t, 1 \leq i, j \leq K, i \neq j, \forall t \geq 0$$
Currently this optimizes for makespan. To get A* optimize for flowtime, we need to change the space to
$$(S^K, \bigcup_{i = 1}^K A), (s_i, t_i)^K_{i = 1}, x_i^t \neq x_j^t, 1 \leq i, j \leq K, i \neq j, \forall t \geq 0$$
## Heuristics

Each problem has its own independent heuristic, we can sum them. But the sum of heuristics is inadmissible for makespan objects. The max of heuristics is admissible. 

The coupled MAPF is hard. 
# Decoupled MAPF
Any fully decoupled search is always incomplete and suboptimal. But if the problem does not require much coordination, it can be fast and often optimal.
## Prioritized Search
```
constraints = {}, order the agents r_1, ..., r_N
for i in range(N):
	p^i = plan for agent r_i (accouting for constraints)
	add resulting path to constraints
```
This is neither complete nor optimal. 

Counter example of completeness:
![[2_20251027001044.png|300]]

The order matters for agents. 
## Priority Based Search and Priority Trees
If some order works, we can try multiple (or all) orderings. 
- States: set of priorities of agents
- Actions: add a priority
- Goal: a state satisfies the goal condition if planning with its set of priorities yields a valid solution.

Priority Based Search (PBS) is a two level hierarchy, the state of top level are search spaces in themselves.
### Planning with Partial Orderings
For a partial ordering on agents $\{A, B, C, D, E\}: \{(A < B), (B < C), (A < D)\}$,
1. Do a topological sort on all agents
2. Plan paths for agents in order, accounting for constraints of parents
### Reducing the Action Space
1. Do not add priorities that create contradictions
2. Only add priorities for relevant pairs of agents.
3. Pick only one collision per state for branching.
### Dealing with Expensive to Evaluate States
When reaching a state in this search space, we DO NOT run a full prioritized search.
We can reuse computation. We only need re-plan to lower priority state.
The orders adding constraint matters. Adding low priority state are cheaper.
### Priority Tree Heuristics
- Agents with many collisions - worst offenders
- Agents with the earliest collision - these lead to early path changes
- Collisions which occur in narrow passages - might lead to large changes
- Collisions whose resolution has smallest (or largest) effect on cost.
These are not estimates of distance to goal. They are number of agents in collision (or number of collisions between agents). They guide the search.

We don't care about optimality
No good way to estimate the cost, Priority Tree states have partial solutions. We use heuristics greedily in a DFS-like fashion. 
# Hybrid MAPF
Coupled Search: Optimal + complete, but slow
Decoupled Search: No guarantees, but fast

To combine these, we can plan in a decoupled way, and couple our state spaces as needed.
## Conflict Based Search (CBS)
1. Plan in decoupled search spaces
2. When collisions occur, add constraints to guarantee this collision does not occur again.
3. Replan, repeat.

The search space is
- States: Set of constraints for each agents.
- Actions: Add a constraint to an agent.
	- Pick a pair of agents in collision
	- Find their first collision
	- Create 2 neighbors
- Goal (Similar to PBS): A state satisfies the goal condition if planning each agent independently with its set of constraints yields a collision free path for all agents.

This, again, is a bi-level search. 

CBS is complete and optimal.
## Improvement
- "Meta agent": fully couple problematic agents
- Conflict prioritization: first resolve conflicts that are cardinal, increase cost.
- Conflict bypass: replace paths with equivalent cost one which avoid conflicts.
- Heuristics for selecting constraint tree nodes for expansion.
## Focal Search
- $g(s, x)$: Distance from start state $s$ to state $x$, increases monotonically
- $h(x, t)$: Estimate cost to get from $x$ to the goal $t$, hopefully decreases, hopefully monotonically. 
- $d(x)$: Estimate steps from $x$ to any goal state. Useful when the path is irrelevant and useful in bi-level search. 
![[2_20251028205917.png]]
## Focal Search on CBS
- $g$: number of steps from starting state, we don't care.
- $c$: the cost of the current solution, is a lower bound on the true cost.
- $d$: the number of conflicts, or agents in conflict.
- $h$: some admissible heuristic. 
## Explicit Estimation Search + CBS
1. If cost of $\min d < w \times \min(c + h)$, select from focal
2. Else if cost of $\min(c + h_{\rm debiased}) < w \times \min (c + h)$, select select inadmissible
3. Else select based on admissible. 
![[2_20251028220500.png]]
> Q: Is EES+CBS still optimal and complete?
# Rule-based MAPF
We can fully resolve conflicts locally (potentially sub-optimally), until they can get back to their original path.

What if
- incomplete: this "what if" is unlikely
- complete: prove progress under assumptions

## Via Experience Database
For example, have a database of all 3x3 sub-grids, solve all problems offline. In online, we find appropriate sub-grid in database and use it.  